// ==============================================================================================================
// Microsoft patterns & practices
// CQRS Journey project
// ==============================================================================================================
// ©2012 Microsoft. All rights reserved. Certain content used with permission from contributors
// http://cqrsjourney.github.com/contributors/members
// Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance 
// with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software distributed under the License is 
// distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
// See the License for the specific language governing permissions and limitations under the License.
// ==============================================================================================================

using System.Threading.Tasks;
using MassTransit;
using Microsoft.EntityFrameworkCore;
using Polly;
using Polly.Contrib.WaitAndRetry;
using Polly.Retry;

namespace Conference
{
    using System;
    using System.Diagnostics;
    using System.Linq;
    using System.Linq.Expressions;
    using Registration.Events;

    // DEV NOTE:
    // This denormalized version of an order is being created in the Conference Management BC, via events
    // coming from the Registration BC (generated by event sourced aggregates).
    // ALL the information is there to generate this denormalized version, but nevertheless, the events
    // seem too granular to keep up with, considering this is a different and isolated bounded context.

    // We feel that reusing the same events that the Registration BC uses internally (for both event sourcing
    // in the write-model, and generating projections for the read model) for integrating between different
    // BCs starts to make the 2 BCs very coupled (regardless of that coupling being through messaging).

    // An alternative is that the Registration BC can create a denormalization like this one on "the other side",
    // and at one point in time publish an event specifically made for integration, with a full dump
    // of the order information.
    // A slightly different alternative, is that we generate the projection on the other side, and publish
    // an event notifying the listeners that a new order is ready, so they (the Conference Mgmt BC)
    // can (asynchronously) make a direct service call and get the information for the order
    // (still getting the fully denormalized order in a single service call).

    // The advisors agreed that handling this many events is OK nevertheless.
    public class OrderEventHandler :
        IConsumer<OrderPlaced>,
        IConsumer<OrderRegistrantAssigned>,
        IConsumer<OrderTotalsCalculated>,
        IConsumer<OrderConfirmed>,
        IConsumer<OrderExpired>,
        IConsumer<SeatAssignmentsCreated>,
        IConsumer<SeatAssigned>,
        IConsumer<SeatAssignmentUpdated>,
        IConsumer<SeatUnassigned>
    {
        private Func<ConferenceContext> contextFactory;
        private readonly AsyncRetryPolicy retryPolicy;
        public OrderEventHandler(Func<ConferenceContext> contextFactory)
        {
            this.contextFactory = contextFactory;
            var delay = Backoff.ConstantBackoff(TimeSpan.FromMilliseconds(200), retryCount: 5, fastFirst: true);

            this.retryPolicy = Policy
                .Handle<Exception>()
                .WaitAndRetryAsync(delay, (exception, i, span) =>
                {
                    Trace.TraceWarning(
                        $"An error occurred in attempt number {i} to access the database in ConferenceService: {exception.Message}");
                });
        }

        public async Task Consume(ConsumeContext<OrderPlaced> @event)
        {
            await using var context = this.contextFactory.Invoke();
            context.Orders.Add(new Order(@event.Message.ConferenceId, @event.Message.SourceId, @event.Message.AccessCode));
            await retryPolicy.ExecuteAsync(async () => await context.SaveChangesAsync());
        }

        public async Task Consume(ConsumeContext<OrderRegistrantAssigned> @event)
        {
            await ProcessOrder(order => order.Id == @event.Message.SourceId, order =>
            {
                order.RegistrantEmail = @event.Message.Email;
                order.RegistrantName = @event.Message.LastName + ", " + @event.Message.FirstName;
            });
        }

        public async Task Consume(ConsumeContext<OrderTotalsCalculated> @event)
        {
            if(!await ProcessOrder(order => order.Id == @event.Message.SourceId, order => order.TotalAmount = @event.Message.Total))
            {
                Trace.TraceError("Failed to locate the order with id {0} to apply calculated totals", @event.Message.SourceId);
            }
        }

        public async Task Consume(ConsumeContext<OrderConfirmed> @event)
        {
            if (!await ProcessOrder(order => order.Id == @event.Message.SourceId, order => order.Status = Order.OrderStatus.Paid))
            {
                Trace.TraceError("Failed to locate the order with {0} to apply confirmed payment.", @event.Message.SourceId);
            }
        }

        public async Task Consume(ConsumeContext<OrderExpired> @event)
        {
            await using var context = this.contextFactory.Invoke();
            var order = await context.Orders.FirstOrDefaultAsync(x => x.Id == @event.Message.SourceId);
            if (order != null)
            {
                context.Orders.Remove(order);
                context.SaveChanges();
            }
        }

        public async Task Consume(ConsumeContext<SeatAssignmentsCreated> @event)
        {
            if (!await ProcessOrder(order => order.Id == @event.Message.OrderId, order => order.AssignmentsId = @event.Message.SourceId))
            {
                Trace.TraceError("Failed to locate the order with {0} for the seat assignments being created with id {1}.", @event.Message.OrderId, @event.Message.SourceId);
            }
        }

        public async Task Consume(ConsumeContext<SeatAssigned> @event)
        {
            if (!await ProcessOrder(order => order.AssignmentsId == @event.Message.SourceId, order =>
            {
                var seat = order.Seats.FirstOrDefault(x => x.Position == @event.Message.Position);
                if (seat != null)
                {
                    seat.Attendee.FirstName = @event.Message.Attendee.FirstName;
                    seat.Attendee.LastName = @event.Message.Attendee.LastName;
                    seat.Attendee.Email = @event.Message.Attendee.Email;
                }
                else
                {
                    order.Seats.Add(new OrderSeat(@event.Message.SourceId, @event.Message.Position, @event.Message.SeatType)
                    {
                        Attendee = new Attendee
                        {
                            FirstName = @event.Message.Attendee.FirstName,
                            LastName = @event.Message.Attendee.LastName,
                            Email = @event.Message.Attendee.Email,
                        }
                    });
                }
            }))
            {
                Trace.TraceError("Failed to locate the order with seat assignments id {0} for the seat assignment being assigned at position {1}.", @event.Message.SourceId, @event.Message.Position);
            }
        }

        public async Task Consume(ConsumeContext<SeatAssignmentUpdated> @event)
        {
            if (!await ProcessOrder(order => order.AssignmentsId == @event.Message.SourceId, order =>
            {
                var seat = order.Seats.FirstOrDefault(x => x.Position == @event.Message.Position);
                if (seat != null)
                {
                    seat.Attendee.FirstName = @event.Message.Attendee.FirstName;
                    seat.Attendee.LastName = @event.Message.Attendee.LastName;
                }
                else
                {
                    Trace.TraceError("Failed to locate the seat being updated at position {0} for assignment {1}.", @event.Message.Position, @event.Message.SourceId);
                }
            }))
            {
                Trace.TraceError("Failed to locate the order with seat assignments id {0} for the seat assignment being updated at position {1}.", @event.Message.SourceId, @event.Message.Position);
            }
        }

        public async Task Consume(ConsumeContext<SeatUnassigned> @event)
        {
            if (!await ProcessOrder(order => order.AssignmentsId == @event.Message.SourceId, order =>
            {
                var seat = order.Seats.FirstOrDefault(x => x.Position == @event.Message.Position);
                if (seat != null)
                {
                    order.Seats.Remove(seat);
                }
                else
                {
                    Trace.TraceError("Failed to locate the seat being unassigned at position {0} for assignment {1}.", @event.Message.Position, @event.Message.SourceId);
                }
            }))
            {
                Trace.TraceError("Failed to locate the order with seat assignments id {0} for the seat being unassigned at position {1}.", @event.Message.SourceId, @event.Message.Position);
            }
        }

        private async Task<bool> ProcessOrder(Expression<Func<Order, bool>> lookup, Action<Order> orderAction)
        {
            await using var context = this.contextFactory.Invoke();
            var order = context.Orders.Include(x => x.Seats).FirstOrDefault(lookup);
            if (order == null) return false;
            orderAction.Invoke(order);
            await context.SaveChangesAsync();
            return true;
        }
    }
}
